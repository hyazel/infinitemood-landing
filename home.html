<!-- Refactored Home Page -->
<div class="relative w-full h-screen overflow-hidden text-[#292D32] flex items-center justify-center">

    <!-- Coded Background: Gradient -->
    <!-- Matches the purple/orange vibe of the 3D art -->
    <!-- cursor-pointer added to ensure clicks bubble correctly on iOS -->
    <div class="absolute inset-0 bg-gradient-to-br from-[#2D2258] via-[#663D58] to-[#FF8C61] cursor-pointer"
        onclick="void(0)"></div>

    <!-- Title (Centered) -->
    <div class="absolute top-8 left-1/2 -translate-x-1/2 z-20">
        <h1 class="text-white text-lg tracking-[0.2em] font-bold" style="font-family: 'Inter', sans-serif;">
            Fragmnt
        </h1>
    </div>

    <!-- Scene Container (Island + Interactivity) -->
    <div class="relative z-10 w-full max-w-full md:max-w-xl lg:max-w-2xl animate-float">
        <!-- Shadow (CSS Radial Gradient) -->
        <div
            class="absolute -bottom-12 left-1/2 -translate-x-1/2 w-[80%] h-[40px] bg-black/30 blur-xl rounded-[100%] animate-shadow-pulse pointer-events-none">
        </div>

        <img src="assets/island_scene.png" alt="Infinite Mood Island" class="w-full h-auto drop-shadow-2xl">

        <!-- Interaction Zone: Tree (Top Left) -->
        <!--
        <div id="zone-tree"
            class="interaction-container absolute top-[25%] left-[5%] md:top-[30%] md:left-[10%] w-[80px] h-[80px] z-20 transition-transform cursor-pointer">
        </div>
        -->

        <!-- Interaction Zone: Cloud (Top Right) -->
        <div id="zone-cloud"
            class="interaction-container absolute top-[5%] right-[15%] md:top-[10%] md:right-[20%] w-[48px] h-[48px] md:w-[80px] md:h-[80px] z-20 transition-transform cursor-pointer">
        </div>
    </div>

    <!-- Play Button -->
    <button id="play-button"
        class="absolute bottom-10 left-1/2 -translate-x-1/2 z-20 flex items-center justify-center w-16 h-16 rounded-full bg-white/10 hover:bg-white/10 backdrop-blur-md border border-white/20 shadow-lg transition-all hover:scale-110 group">
        <!-- Play Icon -->
        <svg id="icon-play" class="w-6 h-6 text-white ml-1" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z" />
        </svg>
        <!-- Pause Icon (Hidden by default) -->
        <svg id="icon-pause" class="w-6 h-6 text-white hidden" fill="currentColor" viewBox="0 0 24 24">
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
        </svg>

        <!-- Ripple Effect -->
        <div class="absolute inset-0 rounded-full animate-ping-slow opacity-0 group-hover:opacity-30"></div>
    </button>

    <!-- Background Elements -->
    <!-- Cloud is now part of the main scene image -->


    <!-- Interaction Zones (Inlined for reliability) -->


</div>

<!-- Template for Interaction Zone (Defined Once) -->


<style>
    @keyframes float {

        0%,
        100% {
            transform: translateY(0);
        }

        50% {
            transform: translateY(-5px);
        }
    }

    @keyframes float-delayed {

        0%,
        100% {
            transform: translateY(0);
        }

        50% {
            transform: translateY(-15px);
        }
    }

    .animate-float {
        animation: float 6s ease-in-out infinite;
    }

    .animate-float-delayed {
        animation: float-delayed 8s ease-in-out infinite;
    }

    .animate-pulse-slow {
        animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    @keyframes shadow-pulse {

        0%,
        100% {
            transform: translateX(-50%) scale(1);
            opacity: 0.3;
        }

        50% {
            transform: translateX(-50%) scale(0.8);
            opacity: 0.15;
        }
    }

    .animate-shadow-pulse {
        animation: shadow-pulse 6s ease-in-out infinite;
    }

    @keyframes bounce-icon {
        0% {
            transform: scale(0.8);
            opacity: 0;
        }

        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .animate-bounce-icon {
        animation: bounce-icon 0.5s ease-in-out forwards;

    }
</style>

<script>
    // Instantiate Interaction Zones
    // No need for DOMContentLoaded because this script runs after HTML injection
    (function () {
        const template = document.getElementById('interaction-zone-template');
        const containers = document.querySelectorAll('.interaction-container');

        console.log("Interaction Zones: Found", containers.length, "containers");

        if (template && containers.length > 0) {
            containers.forEach(container => {
                // Clear container just in case
                container.innerHTML = '';
                const clone = template.content.cloneNode(true);
                container.appendChild(clone);

                // Debug visual to ensure it exists and has size
                // container.style.border = "2px solid red"; 
                // container.style.backgroundColor = "rgba(255, 0, 0, 0.2)";

                // Add explicit click listener to container to verify it receives clicks
                container.addEventListener('click', () => console.log("Interaction Zone Clicked:", container.id));
            });
        } else {
            console.warn("Interaction zones or template not found");
        }
    })();
</script>

<script>
    // Audio Control Logic
    (function () {
        const playBtn = document.getElementById('play-button');
        const iconPlay = document.getElementById('icon-play');
        const iconPause = document.getElementById('icon-pause');
        let isAudioPlaying = false;

        window.searchForFmod = () => {
            // ... existing fallback ...
        }

        if (playBtn) {
            playBtn.addEventListener('click', () => {
                if (!isAudioPlaying) {
                    if (typeof playEvent === 'function') {
                        playEvent(1);
                        isAudioPlaying = true;
                        iconPlay.classList.add('hidden');
                        iconPause.classList.remove('hidden');
                        playBtn.classList.add('bg-white/30');

                        // Start Evolution Engine
                        if (window.EvolutionManager && window.LofiConfig) {
                            window.EvolutionManager.start(window.LofiConfig);
                        }
                    }
                } else {
                    if (typeof playEvent === 'function') {
                        playEvent(2);
                        isAudioPlaying = false;
                        iconPlay.classList.remove('hidden');
                        iconPause.classList.add('hidden');
                        playBtn.classList.remove('bg-white/30');

                        // Stop Evolution Engine
                        if (window.EvolutionManager) {
                            window.EvolutionManager.stop();
                        }
                    }
                }
            });
        }
    })();
</script>

<script>
    // --- Parameter Slider Logic (Crystal Version) ---
    (function () {
        class ParameterSlider {
            constructor(targetZoneSelector, config = {}) {
                this.target = document.querySelector(targetZoneSelector);
                this.config = config;
                this.currentLevel = 0;
                this.isOpen = false;

                if (!this.target) return;

                this.init();
            }

            init() {
                const template = document.getElementById('parameter-slider-template');
                if (!template) return;

                const clone = template.content.cloneNode(true);
                this.element = clone.querySelector('.parameter-slider');

                // Determine Mobile State
                this.isMobile = window.innerWidth < 768;

                if (this.isMobile) {
                    // Mobile: Fixed Center
                    this.element.style.position = 'fixed';
                    this.element.style.top = '50%';
                    this.element.style.left = '50%';
                    this.element.style.marginLeft = '0';
                    this.element.style.marginTop = '0';
                    // Transform handles centering
                    this.element.style.transform = 'translate(-50%, -50%) scale(0)';

                    // Add z-index to ensure it sits on top of everything
                    this.element.style.zIndex = '100';
                } else {
                    // Desktop: Absolute Side (Right of cloud)
                    this.element.style.position = 'absolute';
                    this.element.style.top = '50%';
                    this.element.style.left = '100%';
                    this.element.style.right = 'auto';
                    this.element.style.marginLeft = '20px';
                    this.element.style.marginTop = '40px';
                    // Transform handles vertical center only
                    this.element.style.transform = 'translateY(-50%) scale(0)';
                    this.element.style.zIndex = '20'; // Normal interaction zone layer
                }

                this.element.style.opacity = '0';
                this.element.style.transition = 'transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease-out';
                this.element.classList.remove('fixed'); // Remove if present from template

                if (this.isMobile) {
                    // If fixed, append to body to ensure it's not clipped by containers
                    document.body.appendChild(this.element);
                } else {
                    this.target.appendChild(this.element);
                }


                // Interaction: Click on Slider Track ONLY
                const track = this.element.querySelector('.slider-track');
                if (track) {
                    track.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Get Y relative to TRACK, not whole container
                        const rect = track.getBoundingClientRect();
                        const y = e.clientY - rect.top;

                        // Height = 256px. 4 Steps = 64px each.
                        // Thresholds: 64, 128, 192
                        let newLevel = 0;
                        if (y < 64) newLevel = 3;
                        else if (y < 128) newLevel = 2;
                        else if (y < 192) newLevel = 1;
                        else newLevel = 0;

                        this.setValue(newLevel);
                    });
                }

                // Toggle Visibility (Icon or Zone click)
                // Mobile: Tap on zone opens centered slider logic handled below.

                const iconContainer = this.element.querySelector('.slider-icon-container');
                if (iconContainer) {
                    iconContainer.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }
                // Close on outside click
                // Attached to window to catch everything
                window.addEventListener('click', (e) => {
                    if (this.isOpen) {
                        const clickedInsideTarget = this.target.contains(e.target);
                        const clickedInsideElement = this.element.contains(e.target);

                        if (!clickedInsideTarget && !clickedInsideElement) {
                            this.close();
                        }
                    }
                }); // Toggle Visibility from Parent Zone
                // Note: If appended to body, we still need the target (zone) click to open it.
                this.target.addEventListener('click', (e) => {
                    // Prevent toggle if clicking inside the slider component
                    if (this.element.contains(e.target)) return;
                    this.toggle();
                });

                // Close on outside click is handled by document listener below
                // Set initial value
                this.setValue(this.config.initialValue || 0);

                // Handle resize? Simplified: reload on significant resize or just set once.
                // For now, simpler to not handle dynamic resize between mobile/desktop layouts live.
            }

            toggle() {
                this.isOpen ? this.close() : this.open();
            }

            open() {
                this.isOpen = true;

                if (this.isMobile) {
                    this.element.style.transform = 'translate(-50%, -50%) scale(1)';
                } else {
                    this.element.style.transform = 'translateY(-50%) scale(1)';
                }

                this.element.style.opacity = '1';

                // Start Snapshot
                if (typeof startMeteoSnapshot === 'function') {
                    startMeteoSnapshot();
                }
            }

            close() {
                this.isOpen = false;

                if (this.isMobile) {
                    this.element.style.transform = 'translate(-50%, -50%) scale(0)';
                } else {
                    this.element.style.transform = 'translateY(-50%) scale(0)';
                }

                this.element.style.opacity = '0';

                // Stop Snapshot
                if (typeof stopMeteoSnapshot === 'function') {
                    stopMeteoSnapshot();
                }
            }

            setValue(level) {
                this.currentLevel = level;

                // Map Level to Top Pixel Position (Height 256px)
                // Thumb Height: 48px (Half = 24px)
                // Centers: 32, 96, 160, 224 (Match dots)
                // Top = Center - 24
                const positions = {
                    3: '8px',    // 32 - 24
                    2: '72px',   // 96 - 24
                    1: '136px',  // 160 - 24
                    0: '200px'   // 224 - 24
                };

                const thumb = this.element.querySelector('.slider-thumb');
                if (thumb) {
                    thumb.style.top = positions[level];
                }

                // Update Bottom Icon
                const bottomIcon = this.element.querySelector('.slider-bottom-icon');
                if (bottomIcon) {
                    const newSrc = `assets/meteo_parameter/level_${level}.png`;
                    // Check if src is different (using getAttribute to avoid full URL mismatch)
                    // Or simple check against currentSrc if stored. 
                    // Let's just force animation if level changed or it's good practice.

                    // Simple logic: Reset animation, update src, start animation
                    bottomIcon.classList.remove('animate-bounce-icon');
                    void bottomIcon.offsetWidth; // Trigger reflow

                    bottomIcon.src = newSrc;
                    bottomIcon.classList.add('animate-bounce-icon');
                }

                // Callback
                if (this.config.onChange) {
                    this.config.onChange(level);
                }
            }
        }

        // Initialize Real Slider for Cloud Zone
        const initSliders = () => {
            const zoneCloud = document.querySelector('#zone-cloud');
            if (zoneCloud) {
                new ParameterSlider('#zone-cloud', {
                    initialValue: 0,
                    onChange: (val) => {
                        console.log("Meteo Level:", val);
                        // Connect to FMOD
                        if (typeof setMeteoLevel === 'function') {
                            setMeteoLevel(val);
                        }
                    }
                });
                console.log("Slider attached to #zone-cloud");
            } else {
                setTimeout(initSliders, 100);
            }
        };

        initSliders();
    })();
</script>